{"0": {
    "doc": "Api Documentation",
    "title": "Java API documentation of the SDK",
    "content": " ",
    "url": "/multicloudj/api-java-doc.html#java-api-documentation-of-the-sdk",
    
    "relUrl": "/api-java-doc.html#java-api-documentation-of-the-sdk"
  },"1": {
    "doc": "Api Documentation",
    "title": "Api Documentation",
    "content": "Java doc link for MultiCloudJ . ",
    "url": "/multicloudj/api-java-doc.html",
    
    "relUrl": "/api-java-doc.html"
  },"2": {
    "doc": "How to Blob store",
    "title": "BucketClient",
    "content": "The BucketClient class in the multicloudj library provides a comprehensive, cloud-agnostic interface to interact with individual buckets in object storage services like AWS S3, Azure Blob Storage, and Google Cloud Storage. This client enables uploading, downloading, deleting, listing, copying, and managing blob metadata and multipart uploads across multiple cloud providers. ",
    "url": "/multicloudj/guides/blobstore-guide.html#bucketclient",
    
    "relUrl": "/guides/blobstore-guide.html#bucketclient"
  },"3": {
    "doc": "How to Blob store",
    "title": "Creating a Client",
    "content": "BucketClient bucketClient = BucketClient.builder(\"aws\") .withRegion(\"us-west-2\") .withBucket(\"my-bucket\") .build(); . You can also configure advanced options: . URI endpoint = URI.create(\"https://custom-endpoint.com\"); URI proxy = URI.create(\"https://proxy.example.com\"); bucketClient = BucketClient.builder(\"aws\") .withRegion(\"us-west-2\") .withBucket(\"my-bucket\") .withEndpoint(endpoint) .withProxyEndpoint(proxy) .build(); . ",
    "url": "/multicloudj/guides/blobstore-guide.html#creating-a-client",
    
    "relUrl": "/guides/blobstore-guide.html#creating-a-client"
  },"4": {
    "doc": "How to Blob store",
    "title": "Uploading Files",
    "content": "Supports various sources: . UploadRequest request = new UploadRequest(\"object-key\"); bucketClient.upload(request, inputStream); bucketClient.upload(request, new File(\"file.txt\")); bucketClient.upload(request, path); bucketClient.upload(request, byteArray); . ",
    "url": "/multicloudj/guides/blobstore-guide.html#uploading-files",
    
    "relUrl": "/guides/blobstore-guide.html#uploading-files"
  },"5": {
    "doc": "How to Blob store",
    "title": "Downloading Files",
    "content": "DownloadRequest request = new DownloadRequest(\"object-key\"); bucketClient.download(request, outputStream); bucketClient.download(request, new File(\"dest.txt\")); bucketClient.download(request, path); bucketClient.download(request, byteArray); . ",
    "url": "/multicloudj/guides/blobstore-guide.html#downloading-files",
    
    "relUrl": "/guides/blobstore-guide.html#downloading-files"
  },"6": {
    "doc": "How to Blob store",
    "title": "Listing Blobs",
    "content": "ListBlobsRequest request = new ListBlobsRequest(); Iterator&lt;BlobInfo&gt; blobs = bucketClient.list(request); while (blobs.hasNext()) { System.out.println(blobs.next().getName()); } . ",
    "url": "/multicloudj/guides/blobstore-guide.html#listing-blobs",
    
    "relUrl": "/guides/blobstore-guide.html#listing-blobs"
  },"7": {
    "doc": "How to Blob store",
    "title": "Deleting Blobs",
    "content": "bucketClient.delete(\"object-key\", null); // optional versionId Collection&lt;BlobIdentifier&gt; toDelete = List.of( new BlobIdentifier(\"object1\"), new BlobIdentifier(\"object2\") ); bucketClient.delete(toDelete); . ",
    "url": "/multicloudj/guides/blobstore-guide.html#deleting-blobs",
    
    "relUrl": "/guides/blobstore-guide.html#deleting-blobs"
  },"8": {
    "doc": "How to Blob store",
    "title": "Copying Blobs",
    "content": "CopyRequest copyRequest = new CopyRequest(); // populate source and destination CopyResponse response = bucketClient.copy(copyRequest); . ",
    "url": "/multicloudj/guides/blobstore-guide.html#copying-blobs",
    
    "relUrl": "/guides/blobstore-guide.html#copying-blobs"
  },"9": {
    "doc": "How to Blob store",
    "title": "Metadata and Tags",
    "content": "BlobMetadata metadata = bucketClient.getMetadata(\"object-key\", null); Map&lt;String, String&gt; tags = bucketClient.getTags(\"object-key\"); bucketClient.setTags(\"object-key\", Map.of(\"env\", \"prod\")); . ",
    "url": "/multicloudj/guides/blobstore-guide.html#metadata-and-tags",
    
    "relUrl": "/guides/blobstore-guide.html#metadata-and-tags"
  },"10": {
    "doc": "How to Blob store",
    "title": "Presigned URLs",
    "content": "PresignedUrlRequest presignedRequest = new PresignedUrlRequest(); URL url = bucketClient.generatePresignedUrl(presignedRequest); . ",
    "url": "/multicloudj/guides/blobstore-guide.html#presigned-urls",
    
    "relUrl": "/guides/blobstore-guide.html#presigned-urls"
  },"11": {
    "doc": "How to Blob store",
    "title": "Multipart Uploads",
    "content": "MultipartUploadRequest initRequest = new MultipartUploadRequest(); MultipartUpload upload = bucketClient.initiateMultipartUpload(initRequest); UploadPartResponse part = bucketClient.uploadMultipartPart(upload, partData); List&lt;UploadPartResponse&gt; parts = List.of(part1, part2); bucketClient.completeMultipartUpload(upload, parts); List&lt;UploadPartResponse&gt; uploadedParts = bucketClient.listMultipartUpload(upload); bucketClient.abortMultipartUpload(upload); . ",
    "url": "/multicloudj/guides/blobstore-guide.html#multipart-uploads",
    
    "relUrl": "/guides/blobstore-guide.html#multipart-uploads"
  },"12": {
    "doc": "How to Blob store",
    "title": "Error Handling",
    "content": "All operations may throw SubstrateSdkException. These can be caught and handled generically: . try { bucketClient.upload(request, new File(\"file.txt\")); } catch (SubstrateSdkException e) { // Handle access denied, IO failure, etc. e.printStackTrace(); } . Use BucketClient when you need full CRUD support and advanced control over blobs inside a single bucket, across any supported cloud provider. ",
    "url": "/multicloudj/guides/blobstore-guide.html#error-handling",
    
    "relUrl": "/guides/blobstore-guide.html#error-handling"
  },"13": {
    "doc": "How to Blob store",
    "title": "How to Blob store",
    "content": " ",
    "url": "/multicloudj/guides/blobstore-guide.html",
    
    "relUrl": "/guides/blobstore-guide.html"
  },"14": {
    "doc": "How to Docstore",
    "title": "Docstore",
    "content": "The DocStoreClient class in the multicloudj library provides a portable abstraction over document store providers like Amazon DynamoDB, Alibaba Tablestore, and Google Firestore. It supports core document operations like create, read, update, delete (CRUD), batching, and querying. ",
    "url": "/multicloudj/guides/docstore-guide.html#docstore",
    
    "relUrl": "/guides/docstore-guide.html#docstore"
  },"15": {
    "doc": "How to Docstore",
    "title": "Overview",
    "content": "Document stores persist semi-structured, schemaless documents, typically as key-value pairs. The DocStoreClient lets you interact with multiple providers through a unified API. Each provider is implemented via a driver extending AbstractDocStore. ",
    "url": "/multicloudj/guides/docstore-guide.html#overview",
    
    "relUrl": "/guides/docstore-guide.html#overview"
  },"16": {
    "doc": "How to Docstore",
    "title": "Creating a Client",
    "content": "To begin using DocStoreClient, use the static builder: . CollectionOptions collectionOptions = new CollectionOptions.CollectionOptionsBuilder() .withTableName(\"chameleon-test\") .withPartitionKey(\"pName\") .withSortKey(\"s\") .withRevisionField(\"docRevision\") .build(); DocStoreClient client = DocStoreClient.builder(\"aws\") .withRegion(\"us-west-2\") .withCollectionOptions(collectionOptions) .build(); . ",
    "url": "/multicloudj/guides/docstore-guide.html#creating-a-client",
    
    "relUrl": "/guides/docstore-guide.html#creating-a-client"
  },"17": {
    "doc": "How to Docstore",
    "title": "Document Representation",
    "content": "The Document class accepts either a user-defined class or a generic map. Option 1: Using a POJO (Player) . @AllArgsConstructor @NoArgsConstructor @Data public class Player { private String pName; private int i; private float f; private boolean b; private String s; } Player player = new Player(\"Alice\", 42, 99.5f, true, \"metadata\"); Document doc = new Document(player); . Option 2: Using a HashMap . Map&lt;String, Object&gt; map = new HashMap&lt;&gt;(); map.put(\"pName\", \"Alice\"); map.put(\"i\", 42); map.put(\"f\", 99.5f); map.put(\"b\", true); map.put(\"s\", \"metadata\"); Document doc = new Document(map); . ",
    "url": "/multicloudj/guides/docstore-guide.html#document-representation",
    
    "relUrl": "/guides/docstore-guide.html#document-representation"
  },"18": {
    "doc": "How to Docstore",
    "title": "Actions",
    "content": "Once you have initialized a docstore client, you can call action methods on it to read, modify, and write documents. These are referred to as actions, and can be executed individually or as part of a batch using an action list. DocStore supports the following types of actions: . | Get retrieves a document. | Create creates a new document. | Replace replaces an existing document. | Put puts a document whether or not it already exists. | Update applies modifications to a document (not supported yet). | Delete deletes a document. | . Each of the following examples illustrates one of these actions. ",
    "url": "/multicloudj/guides/docstore-guide.html#actions",
    
    "relUrl": "/guides/docstore-guide.html#actions"
  },"19": {
    "doc": "How to Docstore",
    "title": "Basic Operations",
    "content": "Create . Create will throw an exception ResourceAlreadyExists if the document already exists. client.create(doc); . Get . To retrieve a document, you must provide a Document initialized with the corresponding object and pre-populate the fields that uniquely identify it (e.g., partition key and sort key): . Player player = new Player(); player.setPName(\"Alice\"); // Assuming pName is the partition key player.setS(\"metadata\"); // Assuming s is the sort key client.get(new Document(player)); . With optional fields you want to retrieve: . client.get(new Document(player), \"pName\", \"f\"); . Replace . Replaces the existing doc, will throw ResourceNotFound is the document doesn’t exist. client.replace(doc); . Put . Put is similar to create but will not throw in case the document doesn’t exist. client.put(doc); . Delete . To delete a document, the input must also have the required key fields populated: . Player player = new Player(); player.setPName(\"Alice\"); player.setS(\"metadata\"); client.delete(new Document(player)); . Update (Not Supported) . client.update(doc, Map.of(\"f\", 120.0f)); // Throws UnSupportedOperationException . ",
    "url": "/multicloudj/guides/docstore-guide.html#basic-operations",
    
    "relUrl": "/guides/docstore-guide.html#basic-operations"
  },"20": {
    "doc": "How to Docstore",
    "title": "Batch Operations",
    "content": "Batch Get . List&lt;Document&gt; docs = List.of( new Document().put(\"pName\", \"Alice\").put(\"s\", \"metadata\"), new Document().put(\"pName\", \"Bob\").put(\"s\", \"stats\") ); client.batchGet(docs); . Batch Put . List&lt;Document&gt; docs = List.of( new Document().put(\"pName\", \"Alice\").put(\"f\", 10.5f), new Document().put(\"pName\", \"Bob\").put(\"f\", 20.0f) ); client.batchPut(docs); . ",
    "url": "/multicloudj/guides/docstore-guide.html#batch-operations",
    
    "relUrl": "/guides/docstore-guide.html#batch-operations"
  },"21": {
    "doc": "How to Docstore",
    "title": "Queries",
    "content": "DocStore’s get action retrieves a single document by its primary key. However, when you need to retrieve or manipulate multiple documents that match a condition, you can use queries. Queries allow you to: . | Retrieve all documents that match specific conditions. | Delete or update documents in bulk based on criteria. | . The query interface is chainable and supports filtering and sorting (depending on driver support). DocStore can also optimize queries automatically. Based on your filter conditions, it attempts to determine whether a global secondary index (GSI) or a local secondary index (LSI) can be used to execute the query more efficiently. This helps reduce latency and improves performance. Queries support the following methods: . | Where: Describes a condition on a document. You can ask whether a field is equal to, greater than, or less than a value. The “not equals” comparison isn’t supported, because it isn’t portable across providers. | OrderBy: Specifies the order of the resulting documents, by field and direction. For portability, you can specify at most one OrderBy, and its field must also be mentioned in a Where clause. | Limit: Limits the number of documents in the result. | . Query query = client.query(); // Apply filtering, sorting, etc. (Depends on driver implementation.) . ",
    "url": "/multicloudj/guides/docstore-guide.html#queries",
    
    "relUrl": "/guides/docstore-guide.html#queries"
  },"22": {
    "doc": "How to Docstore",
    "title": "Advanced Usage",
    "content": "Action Lists . ActionList actions = client.getActions(); actions.put(doc1).get(doc2).delete(doc3); actions.run(); . You can also chain operations directly using the fluent API with enableAtomicWrites() for atomic execution: . client.getActions() .create(new Document(new Player(\"Alice\", 1, 3.99f, true, \"CA\"))) .create(new Document(new Player(\"Bob\", 2, 3.99f, true, \"PT\"))) .create(new Document(new Player(\"Carol\", 3, 3.99f, true, \"PA\"))) .enableAtomicWrites() .create(new Document(new Player(\"Dave\", 4, 3.99f, true, \"TX\"))) .create(new Document(new Player(\"Eve\", 5, 3.99f, true, \"OR\"))) .create(new Document(new Player(\"Frank\", 6, 3.99f, true, \"NJ\"))) .run(); . Atomic Writes: . If you want to write your documents atomically, just use the enableAtomicWrites as above and all the writes are this will be executed atomically. Close the Client . client.close(); . ",
    "url": "/multicloudj/guides/docstore-guide.html#advanced-usage",
    
    "relUrl": "/guides/docstore-guide.html#advanced-usage"
  },"23": {
    "doc": "How to Docstore",
    "title": "How to Docstore",
    "content": " ",
    "url": "/multicloudj/guides/docstore-guide.html",
    
    "relUrl": "/guides/docstore-guide.html"
  },"24": {
    "doc": "Exception Handling",
    "title": "Exception Handling in Substrate SDK",
    "content": " ",
    "url": "/multicloudj/design/errors.html#exception-handling-in-substrate-sdk",
    
    "relUrl": "/design/errors.html#exception-handling-in-substrate-sdk"
  },"25": {
    "doc": "Exception Handling",
    "title": "How Does Exception Handling Work for SDK Users?",
    "content": "Substrate SDK defines substrate-agnostic exceptions for end users, so they don’t have to deal with substrate-specific exceptions directly. The SDK wraps all exceptions from cloud providers in a standardized wrapper based on the exception type before propagating it to the end user. Some broadly categorized exceptions include: . | SubstrateSdkException –&gt; Base class for all the exceptions | AccessDeniedException | ResourceNotFoundException | ResourceAlreadyExistsException | ResourceExhaustedException | InvalidArgumentException | FailedPreConditionException | DeadlineExceededException | ResourceConflictException | UnAuthorizedException | UnSupportedOperationException | UnknownException –&gt; This is used when no predefined mapping exists. Ideally, as the SDK evolves, there should be no occurrences of this exception. | . ",
    "url": "/multicloudj/design/errors.html#how-does-exception-handling-work-for-sdk-users",
    
    "relUrl": "/design/errors.html#how-does-exception-handling-work-for-sdk-users"
  },"26": {
    "doc": "Exception Handling",
    "title": "How Does Exception Handling Work for Provider Implementations?",
    "content": "Handling Server-Side Exceptions . Server-side exceptions are relatively straightforward because provider implementations do not need to process them explicitly. These exceptions are considered RunTimeExceptions, which are thrown to the client layer and wrapped according to the predefined mapping. When Provider Implementations Need to Throw Exceptions . There are cases where provider implementations must throw SubstrateSdkException themselves. Some examples include: . | Input Validation Failures . | If a provider implementation validates input parameters and detects an issue, it can throw an InvalidArgumentException directly. | . | Converting Server-Side Exceptions to Different Semantics . | In some cases, a provider implementation may need to reinterpret server-side exceptions. | Example: In DocStore, the create API expects the item not to exist, while the put API does not have this constraint. If a key already exists, the provider must decide which exception to throw based on the API semantics. | . | . Exception Wrapping . | If the exception is already a subclass of SubstrateSdkException, it is not re-wrapped. | Otherwise, exceptions are wrapped according to predefined mappings to ensure a consistent experience for SDK users. | . ",
    "url": "/multicloudj/design/errors.html#how-does-exception-handling-work-for-provider-implementations",
    
    "relUrl": "/design/errors.html#how-does-exception-handling-work-for-provider-implementations"
  },"27": {
    "doc": "Exception Handling",
    "title": "Exception Handling",
    "content": " ",
    "url": "/multicloudj/design/errors.html",
    
    "relUrl": "/design/errors.html"
  },"28": {
    "doc": "MultiCloudJ Overview",
    "title": "MultiCloudJ",
    "content": "Multi-substrate Java SDK providing unified and substrate-neutral interfaces for cloud services such as Security Token Service (STS), Blob Storage, Key-Value Store, and more. ",
    "url": "/multicloudj/#multicloudj",
    
    "relUrl": "/#multicloudj"
  },"29": {
    "doc": "MultiCloudJ Overview",
    "title": "Maven Dependencies",
    "content": "&lt;dependency&gt; &lt;groupId&gt;com.salesforce.multicloudj&lt;/groupId&gt; &lt;artifactId&gt;{service}-client&lt;/artifactId&gt; &lt;version&gt;{version}&lt;/version&gt; &lt;/dependency&gt; . ",
    "url": "/multicloudj/#maven-dependencies",
    
    "relUrl": "/#maven-dependencies"
  },"30": {
    "doc": "MultiCloudJ Overview",
    "title": "Running Examples",
    "content": "MultiCloudJ includes various example programs demonstrating how to interact with supported services like STS, Blob Storage, and Doc Stores. Java examples are located in the examples directory. To run an example: . ",
    "url": "/multicloudj/#running-examples",
    
    "relUrl": "/#running-examples"
  },"31": {
    "doc": "MultiCloudJ Overview",
    "title": "Service supported as of now",
    "content": "MultiCloudJ provides substrate-neutral interfaces supporting the following service: . | STS (Security Token Service) | BlobStore | Document Store | . ",
    "url": "/multicloudj/#service-supported-as-of-now",
    
    "relUrl": "/#service-supported-as-of-now"
  },"32": {
    "doc": "MultiCloudJ Overview",
    "title": "Integration with Cloud Providers",
    "content": "MultiCloudJ provides substrate-neutral interfaces supporting multiple cloud providers, including: . | AWS | Alibaba | GCP | . ",
    "url": "/multicloudj/#integration-with-cloud-providers",
    
    "relUrl": "/#integration-with-cloud-providers"
  },"33": {
    "doc": "MultiCloudJ Overview",
    "title": "Where to Go from Here",
    "content": "Documentation and Guides: . | How to guides: Introduction to MultiCloudJ and getting started quickly. | Design decisions: Introduction to MultiCloudJ and getting started quickly. | . API Documentation: . | Java API Documentation (Javadoc) | . Community and Support: . | GitHub Issues | Discussion Forum | Contribution Guidelines | . Additional Resources: . | MultiCloudJ Homepage | Release Notes | Examples | . ",
    "url": "/multicloudj/#where-to-go-from-here",
    
    "relUrl": "/#where-to-go-from-here"
  },"34": {
    "doc": "MultiCloudJ Overview",
    "title": "MultiCloudJ Overview",
    "content": " ",
    "url": "/multicloudj/",
    
    "relUrl": "/"
  },"35": {
    "doc": "Design",
    "title": "Design guides",
    "content": "Welcome to the MultiCloudJ Design Guides. This section provides concise, task-focused guides to help you understand multiple design decisions of the SDK. ",
    "url": "/multicloudj/design/#design-guides",
    
    "relUrl": "/design/#design-guides"
  },"36": {
    "doc": "Design",
    "title": "Layers of the SDK",
    "content": " ",
    "url": "/multicloudj/design/#layers-of-the-sdk",
    
    "relUrl": "/design/#layers-of-the-sdk"
  },"37": {
    "doc": "Design",
    "title": "Error Handling",
    "content": " ",
    "url": "/multicloudj/design/#error-handling",
    
    "relUrl": "/design/#error-handling"
  },"38": {
    "doc": "Design",
    "title": "Flexibility",
    "content": " ",
    "url": "/multicloudj/design/#flexibility",
    
    "relUrl": "/design/#flexibility"
  },"39": {
    "doc": "Design",
    "title": "Design",
    "content": " ",
    "url": "/multicloudj/design/",
    
    "relUrl": "/design/"
  },"40": {
    "doc": "Usage Guides",
    "title": "How-To Guides",
    "content": "Welcome to the MultiCloudJ How-To Guides. This section provides concise, task-focused guides designed to help you accomplish common goals using MultiCloudJ’s cloud-agnostic interfaces. Each guide is grouped by API and includes practical examples and usage patterns. ",
    "url": "/multicloudj/guides/#how-to-guides",
    
    "relUrl": "/guides/#how-to-guides"
  },"41": {
    "doc": "Usage Guides",
    "title": "🛡️ STS",
    "content": "Learn how to get access credentials using roles/service accounts etc. | STS | . ",
    "url": "/multicloudj/guides/#%EF%B8%8F-sts",
    
    "relUrl": "/guides/#️-sts"
  },"42": {
    "doc": "Usage Guides",
    "title": "☁️ Blob",
    "content": "Learn how to manage object storage (uploading, downloading, listing blobs) in a cloud-neutral way. | Blob Store | . ",
    "url": "/multicloudj/guides/#%EF%B8%8F-blob",
    
    "relUrl": "/guides/#️-blob"
  },"43": {
    "doc": "Usage Guides",
    "title": "📄 Docstore",
    "content": "Work with document-oriented databases using a consistent interface. | Docstore | . ",
    "url": "/multicloudj/guides/#-docstore",
    
    "relUrl": "/guides/#-docstore"
  },"44": {
    "doc": "Usage Guides",
    "title": "📬 Pub/Sub",
    "content": "Use publish/subscribe systems to send and receive messages. | Pubsub | . Explore these guides to master the MultiCloudJ SDK and build robust multi-cloud Java applications with ease. ",
    "url": "/multicloudj/guides/#-pubsub",
    
    "relUrl": "/guides/#-pubsub"
  },"45": {
    "doc": "Usage Guides",
    "title": "Usage Guides",
    "content": " ",
    "url": "/multicloudj/guides/",
    
    "relUrl": "/guides/"
  },"46": {
    "doc": "Layers",
    "title": "Layers",
    "content": " ",
    "url": "/multicloudj/design/layers.html",
    
    "relUrl": "/design/layers.html"
  },"47": {
    "doc": "Layers",
    "title": "Introduction",
    "content": "The Substrate SDK uses a layered architecture to provide a clean separation between the public API, internal abstractions, and provider-specific implementations. This architecture enables: . | A consistent, substrate-agnostic experience for end users | Easy addition of new cloud providers | Clear separation of concerns | Maintainable and testable code | . ",
    "url": "/multicloudj/design/layers.html#introduction",
    
    "relUrl": "/design/layers.html#introduction"
  },"48": {
    "doc": "Layers",
    "title": "Components",
    "content": ". The architecture consists of three main layers: . | Portable Layer (Top) - The public-facing API that users interact with | Driver Layer (Middle) - The abstraction layer that defines common interfaces | Provider Layer (Bottom) - The implementation layer for specific cloud providers | . ",
    "url": "/multicloudj/design/layers.html#components",
    
    "relUrl": "/design/layers.html#components"
  },"49": {
    "doc": "Layers",
    "title": "Portable Layer",
    "content": "The portable layer is the most important and front-facing layer for end users. End users should mostly interact with the portable Layer to make cloud service calls. The portable Layer should expose all necessary functions/APIs for the end user. For example, for a blobstore service, it can expose methods like upload, download, delete, etc., through the portable Layer. Characteristics of an ideal portable Layer: . | The portable Layer should be substrate-agnostic, containing no substrate-specific logic. It should offer a substrate-agnostic experience for the end user. | The portable Layer should accept the substrate(provider) value from the end user and initiate the appropriate session on that substrate. (We might consider that empty provider will pick whatever provider it finds first in the classpath, if required). | The portable Layer should allow users to provide substrate-agnostic inputs such as region name, credentials through a credentials provider defined in Substrate SDK, bucket name (for blob services), etc. | The portable Layer should only expose functions that are supported across all substrates. It should not support or expose features that work on one substrate but not on others. | The portable Layer should strive to provide the best experience for the end user, requiring as little information as possible. | . Example usage of the portable Layer for blob storage and uploading the blob: . // hardcodes for illustration purposes values should be outside of the service code String substrate = \"aws\" String region = \"us-east-1\" // Setting up session credentials - // these are optional and ideally in prod, this is not required // since the k8s pods are set with default credentials and Substrate SDK // uses the default credentials in that case. StsCredentials credentials = new StsCredentials( \"accessKeyId\", \"accessKeySecret\", \"sessionToken\"); CredentialsOverrider credsOverrider = new CredentialsOverrider .Builder(CredentialsType.SESSION).withSessionCredentials(credentials).build(); // Initiate the substrate agnostic BucketClient BucketClient client = BucketClient.builder(substrate) .withBucket(\"chameleon-java\") .withRegion(region) .withCredentialsOverrider(credsOverrider).build(); // Prepare the substrate agnostic UploadRequest UploadRequest uploadRequest = new UploadRequest.Builder() .withKey(\"bucket-path/chameleon.jpg\") // Upload the content UploadResponse response = client.upload(uploadRequest, \"dummy-content\"); . The above example demonstrates that the end user wants to open the client for the blob storage in the AWS substrate to the bucket “chameleon-java” in the region “us-east-1”. The client is used to upload/write the blob in the bucket. In this example, the portable fulfills all the requirements as discussed above: . | There is no substrate specific logic exposed on the portable Layer. From the code block, there is no substrate specific exposure and this logic works in the same manner for other substrates by just providing a different substrate value. | portable Layer forces the client the provide a substrate value, it doesn’t assume or interpret the substrate based on the runtime. | It provides a way to supply inputs to open the session in a substrate agnostic manner. | It asks the minimum amount of information from the end user without knowing the internals of the SDK. | . ",
    "url": "/multicloudj/design/layers.html#portable-layer",
    
    "relUrl": "/design/layers.html#portable-layer"
  },"50": {
    "doc": "Layers",
    "title": "Driver Layer",
    "content": "The driver layer is a layer behind the portable Layer which defines the abstract functions and implementations for each substrate/provider. The driver layer can also include wrapper logic on top of abstract functions to further simplify portable Layer. Structure . The basic structure of abstract Blob Store looks like this which defines some variables required for the provider implementation such as region and the provider id: . public abstract class AbstracBlobtore { protected final String providerId; protected final String region; protected final String bucket; // Abstract methods for substrate-specific implementations protected abstract UploadResponse doUpload(UploadRequest uploadRequest); protected abstract DownloadResponse doDownload(DownloadRequest downloadRequest); protected abstract void doDelete(String key); } . Why do need a separate driver layer? . While it’s possible to achieve the abstraction of service capabilities without this driver layer and instead make the portable layer an abstract class, there are numerous benefits to keeping the portable layer separate. These benefits include: . Separation of concerns: . Abstract classes deal with internal code of SDK and abstract methods for providers to implement where as portable Layer or client is all about external facing code. We can keep the portable Layer light weight and to the point. Driver abstraction consist of: . | Common methods for logic which applies to all providers | Abstract methods to be implemented by providers | . Prevention of leaky abstractions: . Having a separate portable Layer prevents the leaky abstractions because the client doesn’t have to deal with or access the driver layer which might expose some internals. Maintainability: . Changing the internal implementations are comparatively safe without breaking portable Layer contracts. Testing: . End users have simple portable layer for mocks and testing. Example: . For instance, the upload method in BucketClient have multiple methods in the backend, such as validateContent to validate if the content is in the right format which is common for all providers. This validateContent method should be internal and not exposed to end users, therefore it can be part of driver layer and keep the BucketClient purely public. Secondly, if we have a prepContent abstraction function in driver which should be implemented by all the provider implementations to prepareContent for specific substrate. Now, let’s say each substrate appends the content with some prefix bytes which are substrate specific. So the upload method is executed as follow behind the scenes: . public UploadResponse upload(UploadRequest uploadRequest) { validation(); &lt;- this is common validation for all substrates prepContent(); &lt;- this is provider specific prep content doUpload(); this is provider specific upload of the content } . Basically we might have several methods which the end user doesn’t care about and should be completely abstracted from the users. These functions should be placed in driver layer, keeping the portable layer purely public and sanitized. ",
    "url": "/multicloudj/design/layers.html#driver-layer",
    
    "relUrl": "/design/layers.html#driver-layer"
  },"51": {
    "doc": "Layers",
    "title": "Provider Layer",
    "content": "Provider layer implements the driver layer for each substrate. Provider layer is for each provider or substrate which powers the API calls from the end users to make substrate specific calls. In the below code example: AWSBlobStore is the provider for blob/blobstore for AWS substrate and implements all the abstract functions in the AWS substrate. public class AWSBlobStore extends AbstractBlobStore { S3Client s3Client; public AWSBlobStore(Builder builder) { s3Client = ... // code logic to build the s3Client by information from builder } @Override protected void doUploadFile(String key, String filePath) { Map&lt;String, String&gt; metadata = new HashMap&lt;&gt;(); PutObjectRequest putOb = PutObjectRequest.builder() .bucket(this.bucketName) .key(key) .metadata(metadata) .build(); s3Client.putObject(putOb, RequestBody.fromFile(new File(filePath))); log.info(\"Successfully placed object\" + \" into bucket \" + bucketName); } @Override public Builder builder() { return new Builder(); } public static class Builder extends AbstractBlobStore.Builder&lt;AwsBlobStore&gt; { public Builder() { providerId(\"aws\"); } @Override public AwsBlobStore build() { return new AwsBlobStore(this); } ... } } . ",
    "url": "/multicloudj/design/layers.html#provider-layer",
    
    "relUrl": "/design/layers.html#provider-layer"
  },"52": {
    "doc": "Layers",
    "title": "Best Practices",
    "content": ". | Keep the Portable Layer Clean . | Only expose substrate-agnostic APIs | Validate inputs before passing to driver layer | Handle common error cases | . | Driver Layer Design . | Define clear interfaces | Include common validation logic | Provide default implementations where possible | Document expected behavior | . | Provider Implementation . | Follow the driver layer contract strictly | Handle provider-specific edge cases | Implement proper error handling | Add provider-specific logging | . | . ",
    "url": "/multicloudj/design/layers.html#best-practices",
    
    "relUrl": "/design/layers.html#best-practices"
  },"53": {
    "doc": "Layers",
    "title": "Common Pitfalls",
    "content": ". | Leaky Abstractions . | Avoid exposing provider-specific types in the portable layer | Don’t let provider-specific exceptions bubble up | Keep provider-specific configuration internal | . | Inconsistent Behavior . | Ensure all providers implement the same behavior | Handle edge cases consistently | Document any provider-specific limitations | . | Performance Issues . | Avoid unnecessary abstraction layers | Cache provider clients when possible | Use efficient data structures | . | . ",
    "url": "/multicloudj/design/layers.html#common-pitfalls",
    
    "relUrl": "/design/layers.html#common-pitfalls"
  },"54": {
    "doc": "How to STS",
    "title": "STS (Security Token Service)",
    "content": "The StsClient class in the multicloudj library provides a portable interface for interacting with cloud provider security token services such as AWS STS, GCP IAM Credentials, or any other compatible implementation. It allows you to obtain temporary credentials, access tokens, and caller identity information in a cloud-neutral way. ",
    "url": "/multicloudj/guides/sts-guide.html#sts-security-token-service",
    
    "relUrl": "/guides/sts-guide.html#sts-security-token-service"
  },"55": {
    "doc": "How to STS",
    "title": "Overview",
    "content": "The StsClient is built on top of provider-specific implementations of AbstractSts. Each provider registers its implementation and is selected dynamically at runtime. To use STS, you must first create a client using the builder() method. ",
    "url": "/multicloudj/guides/sts-guide.html#overview",
    
    "relUrl": "/guides/sts-guide.html#overview"
  },"56": {
    "doc": "How to STS",
    "title": "Creating a Client",
    "content": "StsClient stsClient = StsClient.builder(\"aws\") .withRegion(\"us-west-2\") .build(); . Optionally, you can set a custom endpoint: . URI endpoint = URI.create(\"https://sts.custom-endpoint.com\"); StsClient stsClient = StsClient.builder(\"aws\") .withRegion(\"us-west-2\") .withEndpoint(endpoint) .build(); . ",
    "url": "/multicloudj/guides/sts-guide.html#creating-a-client",
    
    "relUrl": "/guides/sts-guide.html#creating-a-client"
  },"57": {
    "doc": "How to STS",
    "title": "Getting Caller Identity",
    "content": "Retrieve the caller identity associated with the current credentials: . CallerIdentity identity = stsClient.getCallerIdentity(); System.out.println(\"Caller: \" + identity.getArn()); . ",
    "url": "/multicloudj/guides/sts-guide.html#getting-caller-identity",
    
    "relUrl": "/guides/sts-guide.html#getting-caller-identity"
  },"58": {
    "doc": "How to STS",
    "title": "Getting an Access Token",
    "content": "Use this when you need an OAuth2-style token (provider support may vary): . GetAccessTokenRequest request = new GetAccessTokenRequest(); StsCredentials token = stsClient.getAccessToken(request); System.out.println(\"Access Token: \" + token.getAccessToken()); . ",
    "url": "/multicloudj/guides/sts-guide.html#getting-an-access-token",
    
    "relUrl": "/guides/sts-guide.html#getting-an-access-token"
  },"59": {
    "doc": "How to STS",
    "title": "Assuming a Role",
    "content": "To assume a different identity (e.g., for cross-account access): . AssumedRoleRequest request = new AssumedRoleRequest(); request.setRoleArn(\"arn:aws:iam::123456789012:role/example-role\"); request.setSessionName(\"example-session\"); StsCredentials credentials = stsClient.getAssumeRoleCredentials(request); System.out.println(\"Temporary Credentials: \" + credentials.getAccessKeyId()); . ",
    "url": "/multicloudj/guides/sts-guide.html#assuming-a-role",
    
    "relUrl": "/guides/sts-guide.html#assuming-a-role"
  },"60": {
    "doc": "How to STS",
    "title": "Error Handling",
    "content": "All errors are translated to SubstrateSdkException subclasses by the underlying driver. The client will automatically map exceptions to meaningful runtime errors based on the provider: . try { CallerIdentity identity = stsClient.getCallerIdentity(); } catch (SubstrateSdkException e) { // Handle known errors: AccessDenied, Timeout, etc. e.printStackTrace(); } . ",
    "url": "/multicloudj/guides/sts-guide.html#error-handling",
    
    "relUrl": "/guides/sts-guide.html#error-handling"
  },"61": {
    "doc": "How to STS",
    "title": "How to STS",
    "content": " ",
    "url": "/multicloudj/guides/sts-guide.html",
    
    "relUrl": "/guides/sts-guide.html"
  }
}
